import React, { useState, useRef, useEffect } from "react";
import jsPDF from "jspdf";
import autoTable from "jspdf-autotable";
import { ToastContainer, toast, Slide } from "react-toastify";
import "react-toastify/dist/ReactToastify.css";
//import { useNavigate } from "react-router-dom";
import { Line } from "react-chartjs-2";
//import { analyzeScanData } from "../utils/openai";
import { analyzeScanData } from "../utils/groq";



import {
  Chart as ChartJS,
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  Title,
  Tooltip,
  Legend,
} from "chart.js";

ChartJS.register(
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  Title,
  Tooltip,
  Legend
);

import scanIcon from "../assets/Images/scan.png";
import startIcon from "../assets/Images/start.png";
import stopIcon from "../assets/Images/stop.png";
import responseIcon from "../assets/Images/response.png";
import progressIcon from "../assets/Images/progress.png";
import aiIcon from "../assets/Images/ai.png";

const API_KEY = import.meta.env.VITE_ZAP_API_KEY;
const BASE_URL = "/zap";

function VulnerabilityScan() {
  const [pluginProgressData, setPluginProgressData] = useState([]);

  const [targetUrl, setTargetUrl] = useState("");
  const [scanStatus, setScanStatus] = useState("");
  const [alerts, setAlerts] = useState([]);
  const [sentMessages, setSentMessages] = useState([]);
  const [loading, setLoading] = useState(false);
  const [scanProgress, setScanProgress] = useState(0);
  const pollingRef = useRef(true);
  //const navigate = useNavigate();
  const [showProgress, setShowProgress] = useState(false);
  const [showResponse, setShowResponse] = useState(false);
  const [showAIReport, setShowAIReport] = useState(false);
  const [aiReport, setAIReport] = useState("");

  const isValidUrl = (url) => {
    try {
      new URL(url);
      return true;
    } catch {
      return false;
    }
  };

  const startScan = async () => {
    if (!isValidUrl(targetUrl)) {
      setScanStatus("Please enter a valid URL including http/https.");
      toast("Invalid URL. Please include http/https.", {
        type: "error",
        theme: "colored",
        autoClose: 5000,
        transition: Slide,
      });
      return;
    }

    toast(`Started scan on ${targetUrl}`, {
      type: "info",
      theme: "colored",
      autoClose: 5000,
      transition: Slide,
    });

    setLoading(true);
    setAlerts([]);
    setSentMessages([]);
    setScanProgress(0);
    pollingRef.current = true;

    try {
      const spiderResp = await fetch(
        `${BASE_URL}/spider/action/scan/?url=${encodeURIComponent(
          targetUrl
        )}&apikey=${API_KEY}`
      );
      const spiderData = await spiderResp.json();
      await pollSpiderStatus(spiderData.scan);

      const activeResp = await fetch(
        `${BASE_URL}/ascan/action/scan/?url=${encodeURIComponent(
          targetUrl
        )}&apikey=${API_KEY}`
      );
      const activeData = await activeResp.json();

      if (activeData.scan) {
        await pollScanStatus(activeData.scan);
      }

      toast(`Scan completed for ${targetUrl}`, {
        type: "success",
        theme: "colored",
        autoClose: 5000,
        transition: Slide,
      });
    } catch (error) {
      setScanStatus(`Error starting scan: ${error.message}`);
      toast(`Scan failed: ${error.message}`, {
        type: "error",
        theme: "colored",
        autoClose: 5000,
        transition: Slide,
      });
    }

    setLoading(false);
  };

  const pollSpiderStatus = async (scanId) => {
    let status = "0";
    while (status !== "100" && pollingRef.current) {
      await new Promise((res) => setTimeout(res, 500));
      const resp = await fetch(
        `${BASE_URL}/spider/view/status/?scanId=${scanId}&apikey=${API_KEY}`
      );
      status = (await resp.json()).status;
    }
  };

  const pollScanStatus = async (scanId) => {
    let status = "0";

    while (status !== "100" && pollingRef.current) {
      await new Promise((res) => setTimeout(res, 1000)); // 1-second interval

      // Fetch scan progress
      const resp = await fetch(
        `${BASE_URL}/ascan/view/status/?scanId=${scanId}&apikey=${API_KEY}`
      );
      status = (await resp.json()).status;
      setScanProgress(Number(status));

      // Fetch plugin scan progress in real-time
      const plugins = await fetchPluginProgress();
      setPluginProgressData(plugins);

      // Fetch HTTP messages
      const msgs = await fetchSentMessages();
      setSentMessages(msgs);
    }

    // Final fetch after scan completes
    if (pollingRef.current) {
      setScanProgress(100);
      await fetchAlerts();
      await fetchSentMessages();
    }
  };

  const stopScan = async () => {
    pollingRef.current = false; // Stop further polling
    setLoading(false); // Hide the stop button
    setScanStatus("Scan stopped by user.");

    try {
      // Stop scans on ZAP
      await fetch(`${BASE_URL}/ascan/action/stop/?apikey=${API_KEY}`);
      await fetch(`${BASE_URL}/spider/action/stop/?apikey=${API_KEY}`);

      // Fetch the latest results
      await fetchAlerts();
      const msgs = await fetchSentMessages();
      setSentMessages(msgs);

      toast("Scan stopped and results fetched.", {
        type: "warning",
        theme: "colored",
        autoClose: 4000,
        transition: Slide,
      });
    } catch (error) {
      toast(`Error stopping scan: ${error.message}`, {
        type: "error",
        theme: "colored",
        autoClose: 4000,
        transition: Slide,
      });
    }
  };

  const fetchAlerts = async () => {
    try {
      const resp = await fetch(
        `${BASE_URL}/core/view/alerts/?baseurl=${encodeURIComponent(
          targetUrl
        )}&apikey=${API_KEY}`
      );
      const data = await resp.json();
      setAlerts(data.alerts || []);
      setScanStatus(`Found ${data.alerts?.length || 0} alerts.`);
      toast.success(`Found ${data.alerts?.length || 0} vulnerabilities`, {
        position: "bottom-center",
        autoClose: 2500,
      });
      return data.alerts || []; // ✅ return alerts
    } catch (error) {
      setScanStatus(`Error fetching alerts: ${error.message}`);
      toast.error(`Error fetching alerts: ${error.message}`, {
        position: "top-center",
        autoClose: 2500,
      });
      return [];
    }
  };

  const fetchPluginProgress = async () => {
    try {
      const response = await fetch(
        `${BASE_URL}/ascan/view/scanners/?apikey=${API_KEY}`
      );
      const json = await response.json();
      const scanners = json.scanners || [];

      console.log("Scanners fetched:", scanners); // <-- ADD THIS

      return scanners.map((scanner) => ({
        id: scanner.id,
        name: scanner.name,
        strength: scanner.attackStrength || "-",
        progress: parseInt(scanner.progress),
        elapsed: scanner.timeStarted
          ? getElapsedTime(scanner.timeStarted)
          : "-",
        requests: scanner.requests || 0,
        alerts: scanner.alertsRaised || 0,
        status: scanner.progress >= 100 ? "✅ Done" : "⏳ Running",
      }));
    } catch (error) {
      console.error("Failed to fetch plugin scanners", error);
      return [];
    }
  };

  // Utility function to format elapsed time
  function getElapsedTime(startTime) {
    const start = new Date(startTime);
    const now = new Date();
    const diff = now - start;
    const seconds = (diff / 1000).toFixed(3);
    const minutes = Math.floor(seconds / 60);
    const remSeconds = (seconds % 60).toFixed(3).padStart(6, "0");
    return `00:${String(minutes).padStart(2, "0")}:${remSeconds}`;
  }

  const fetchSentMessages = async () => {
    try {
      const resp = await fetch(
        `${BASE_URL}/core/view/messages/?baseurl=${encodeURIComponent(
          targetUrl
        )}&apikey=${API_KEY}`
      );

      if (!resp.ok) {
        throw new Error(`ZAP responded with status: ${resp.status}`);
      }

      const data = await resp.json();

      const messages = data.messages || [];
      if (messages.length === 0) {
        console.warn("No messages found for target:", targetUrl);
        return [];
      }

      const detailedMessages = await Promise.all(
        messages.map(async (msg) => {
          try {
            const msgResp = await fetch(
              `${BASE_URL}/core/view/message/?id=${msg.id}&apikey=${API_KEY}`
            );

            if (!msgResp.ok) {
              throw new Error(
                `Failed to fetch message ${msg.id}: ${msgResp.status}`
              );
            }

            const msgData = await msgResp.json();
            return {
              id: msg.id,
              timeSent: msgData.message.timeSent,
              timeReceived: msgData.message.timeReceived,
              method: msgData.message.requestHeader?.split(" ")[0] || "-",
              url: msgData.message.requestHeader?.split(" ")[1] || "-",
              statusCode:
                msgData.message.responseHeader?.match(
                  /HTTP\/\d\.\d (\d{3})/
                )?.[1] || "-",
              reasonPhrase:
                msgData.message.responseHeader?.match(
                  /HTTP\/\d\.\d \d{3} (.+)/
                )?.[1] || "-",
              rtt: msgData.message.rtt,
              responseHeader: msgData.message.responseHeader,
              responseBody: msgData.message.responseBody,
            };
          } catch (err) {
            console.error(`Error fetching message ${msg.id}:`, err);
            return { id: msg.id };
          }
        })
      );

      return detailedMessages;
    } catch (error) {
      console.error("Failed to fetch sent messages from ZAP:", error.message);
      return [];
    }
  };

  const getRiskCounts = () => {
    const counts = {
      Critical: 0,
      High: 0,
      Medium: 0,
      Low: 0,
      Informational: 0,
    };

    alerts.forEach((alert) => {
      if (Object.prototype.hasOwnProperty.call(counts, alert.risk)) {
        counts[alert.risk]++;
      }
    });

    return counts;
  };

  // Generate AI Report from filtered alerts
  const generateAIReport = async () => {
    toast("Analyzing vulnerabilities by priority...", {
      type: "info",
      autoClose: 2000,
    });

    const severityOrder = [
      "Critical",
      "High",
      "Medium",
      "Low",
      "Informational",
    ];

    const groupedAlerts = severityOrder.reduce((acc, severity) => {
      acc[severity] = alerts.filter((alert) => alert.risk === severity);
      return acc;
    }, {});

    const limitedAlerts = [
      ...groupedAlerts["Critical"],
      ...groupedAlerts["High"],
      ...groupedAlerts["Medium"].slice(0, 5),
      ...groupedAlerts["Low"].slice(0, 5),
      ...groupedAlerts["Informational"].slice(0, 1),
    ];

    const sortedAlerts = limitedAlerts.map(
      ({ alert, risk, description, solution, url }) => ({
        alert: alert?.slice(0, 100) || "Unknown alert",
        risk,
        description:
          description?.slice(0, 400).trim() || "No description provided.",
        solution: solution?.slice(0, 400).trim() || "No solution provided.",
        url,
      })
    );

    const prompt = `Analyze these web security vulnerabilities by severity. For each, give:

- Vulnerability title
- Risk level
- Short description
- Security impact
- Recommended solution
- Affected URLs

Format like this:

- Risk: <severity>
- Vulnerability: <title>
- Description: <summary>
- Impact: <risks>
- Solution: <fixes>
- URL: <pages>

Be clear, concise, and security-focused.`;

    const report = await analyzeScanData(sortedAlerts, prompt, 1500);

    // 🔍 Remove unwanted heading
    const cleanedReport = report
      .replace(/^#+\s*Vulnerability Analysis\s*/i, "")
      .trim();

    setAIReport(cleanedReport);
  };

  useEffect(() => {
    return () => {
      pollingRef.current = false;
    };
  }, []);

  return (
    <div className="flex flex-col gap-6 max-w-6xl mx-auto mt-10">
      {/* Scan Section */}
      <div
        className="mt-6 border border-gray-200 shadow-xl rounded-xl p-4"
        style={{
          background:
            "linear-gradient(to bottom, #d6f8df 0%, #ffd6e8 40%, #d6f8df 100%)",
          color: "#3e67c8",
        }}
      >
        <h2 className="text-2xl font-bold mb-4">ZAP Vulnerability Scanner</h2>

        <div className="flex items-center gap-4">
          <div className="relative flex-grow">
            <div className="relative w-full">
              <div
                className="absolute top-0 left-0 h-full bg-[#3e67c8] rounded"
                style={{
                  width: `${scanProgress}%`,
                  transition: "width 0.3s ease",
                  zIndex: 0,
                }}
              />

              <input
                type="text"
                className="w-full border border-gray-300 rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-400 relative"
                placeholder="Enter target URL (e.g. https://example.com)"
                value={targetUrl}
                onChange={(e) => setTargetUrl(e.target.value)}
                disabled={loading}
                style={{
                  backgroundColor: "transparent",
                  color: scanProgress > 30 ? "white" : "green",
                  position: "relative",
                  zIndex: 1,
                }}
              />

              {loading && (
                <div
                  className="absolute top-1/2 transform -translate-y-1/2 bg-yellow-400 text-black text-xs font-bold rounded-full px-3 py-1"
                  style={{
                    left: `calc(${Math.min(
                      Math.max(scanProgress, 25),
                      95
                    )}% - 30px)`,
                    transition: "left 0.3s ease",
                    zIndex: 2,
                  }}
                >
                  {scanProgress}%
                </div>
              )}
            </div>
          </div>

          <button
            onClick={startScan}
            disabled={loading || !targetUrl}
            className={`flex items-center justify-center hover:scale-110 transition ${
              loading ? "animate-pulse" : ""
            }`}
          >
            <img
              src={loading ? scanIcon : startIcon}
              alt="Scan"
              className="w-16 h-16"
            />
          </button>
        </div>

        <div className="flex items-center gap-4 text-gray-700 mt-2">
          <div>{scanStatus}</div>

          {/* Progress & Response Icons */}
          <div className="flex items-center gap-6">
            <img
              src={progressIcon}
              alt="Progress"
              className="w-8 h-8 hover:scale-110 transition-transform cursor-pointer"
              title="Scan Progress"
              onClick={() => {
                setShowProgress(true);
                setShowResponse(false);
                setShowAIReport(false); // Close AI report if open
              }}
            />
            <img
              src={responseIcon}
              alt="Response"
              className="w-8 h-8 hover:scale-110 transition-transform cursor-pointer"
              title="Response Chart"
              onClick={() => {
                setShowResponse(true);
                setShowProgress(false);
                setShowAIReport(false); // Close AI report if open
              }}
            />
            <img
              src={aiIcon}
              alt="AI"
              className="w-8 h-8 hover:scale-110 transition-transform cursor-pointer"
              title="AI Security Analysis"
              onClick={() => {
                setShowAIReport(true);
                setShowProgress(false);
                setShowResponse(false); // Close other windows if open
              }}
            />
          </div>

          {showProgress && (
            <div className="fixed top-24 right-[400px] w-[700px] h-[500px] bg-white rounded-xl shadow-xl p-4 z-50 overflow-y-auto">
              <div className="flex justify-between items-center mb-2">
                <h3 className="text-lg font-bold text-gray-700">
                  Scan Plugin Progress
                </h3>
                <button
                  className="text-xl text-red-500 hover:text-red-700 hover:scale-125 transition-transform"
                  onClick={() => setShowProgress(false)}
                >
                  ×
                </button>
              </div>

              {/* Scrollable list of plugin progress */}
              <table className="min-w-full text-xs text-gray-700 border-collapse">
                <thead>
                  <tr className="bg-gray-100 text-left">
                    <th className="p-2 border">Plugin</th>
                    <th className="p-2 border">Strength</th>
                    <th className="p-2 border">Progress</th>
                    <th className="p-2 border">Elapsed</th>
                    <th className="p-2 border">Reqs</th>
                    <th className="p-2 border">Alerts</th>
                    <th className="p-2 border">Status</th>
                  </tr>
                </thead>
                <tbody>
                  {pluginProgressData.map((plugin, idx) => (
                    <tr key={idx} className="hover:bg-gray-50">
                      <td className="p-2 border">{plugin.name}</td>
                      <td className="p-2 border">{plugin.strength}</td>
                      <td className="p-2 border">{plugin.progress}%</td>
                      <td className="p-2 border">{plugin.elapsed}</td>
                      <td className="p-2 border">{plugin.requests}</td>
                      <td className="p-2 border">{plugin.alerts}</td>
                      <td className="p-2 border">{plugin.status}</td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          )}

          {showResponse && (
            <div className="fixed top-24 right-[400px] w-[700px] bg-white rounded-xl shadow-xl p-4 z-50">
              <div className="flex justify-between items-center mb-2">
                <h3 className="text-lg font-bold text-gray-700">
                  Response Time Chart
                </h3>
                <button
                  className="text-xl text-red-500 hover:text-red-700 hover:scale-125 transition-transform"
                  onClick={() => setShowResponse(false)}
                >
                  ×
                </button>
              </div>

              {(() => {
                const grouped = groupResponsesByTime(sentMessages);
                const times = Object.keys(grouped);
                const codeClasses = ["1xx", "2xx", "3xx", "4xx", "5xx"];
                const colors = {
                  "1xx": "gray",
                  "2xx": "green",
                  "3xx": "blue",
                  "4xx": "magenta",
                  "5xx": "red",
                };

                const datasets = codeClasses.map((cls) => ({
                  label: cls,
                  data: times.map((t) => grouped[t][cls] || 0),
                  borderColor: colors[cls],
                  backgroundColor: "transparent",
                  fill: false,
                }));

                return (
                  <Line
                    data={{
                      labels: times,
                      datasets,
                    }}
                    options={{
                      responsive: true,
                      plugins: { legend: { display: true } },
                      scales: {
                        y: {
                          title: { display: true, text: "Responses / Second" },
                        },
                        x: {
                          title: { display: true, text: "Time" },
                        },
                      },
                    }}
                  />
                );
              })()}
            </div>
          )}

          {showAIReport && (
            <div
              className="fixed top-24 right-[400px] w-[750px] h-[550px] flex flex-col justify-between border border-gray-200 z-50 shadow-lg rounded-2xl"
              style={{
                background:
                  "linear-gradient( #fce7f3 0%, #e0f2fe 50%, #e0f2fe 100%)",
                color: "#3e67c8",
              }}
            >
              {/* Header - Fixed */}
              <div className="p-4 bg-opacity-80 sticky top-0 z-10">
                <div className="flex justify-between items-center mb-3">
                  <h2 className="text-2xl font-bold">AI Security Analysis</h2>
                  <button
                    className="text-2xl text-red-500 hover:text-red-700 hover:scale-125 transition-transform"
                    onClick={() => setShowAIReport(false)}
                  >
                    ×
                  </button>
                </div>

                <div className="flex gap-4">
                  <button
                    className="px-5 py-2 rounded bg-blue-600 hover:bg-blue-700 text-white shadow"
                    onClick={() => generateAIReport()}
                  >
                    Report
                  </button>
                  <button
                    className="px-5 py-2 rounded bg-green-600 hover:bg-green-700 text-white shadow"
                    onClick={() =>
                      toast(
                        "Analysis button clicked. (Add future AI analysis here)",
                        {
                          type: "info",
                          autoClose: 2000,
                        }
                      )
                    }
                  >
                    Analysis
                  </button>
                </div>
              </div>

              {/* Vulnerability List - Scrollable */}
              <div className="flex-1 overflow-y-auto p-4 space-y-6 text-sm leading-relaxed">
                {(() => {
                  const groups = [];
                  let currentGroup = [];
                  aiReport.split("\n").forEach((line) => {
                    const trimmed = line.trim();
                    if (trimmed === "") return;
                    if (
                      trimmed.startsWith("⚠️ Risk:") &&
                      currentGroup.length > 0
                    ) {
                      groups.push([...currentGroup]);
                      currentGroup = [];
                    }
                    currentGroup.push(line);
                  });
                  if (currentGroup.length > 0) groups.push([...currentGroup]);

                  return groups.map((group, groupIndex) => {
                    const riskLine =
                      group.find((l) => l.startsWith("⚠️ Risk:")) || "";
                    const risk = riskLine.replace("⚠️ Risk:", "").trim();
                    let borderColor = "border-blue-500";
                    if (risk === "Critical") borderColor = "border-red-600";
                    else if (risk === "High") borderColor = "border-orange-500";
                    else if (risk === "Medium")
                      borderColor = "border-yellow-500";
                    else if (risk === "Low") borderColor = "border-green-500";
                    else if (risk === "Informational")
                      borderColor = "border-gray-500";

                    return (
                      <div
                        key={groupIndex}
                        className={`bg-white rounded-lg shadow-md p-4 border-l-8 ${borderColor} space-y-2`}
                      >
                        {group.map((line, index) => (
                          <p key={index}>{line}</p>
                        ))}
                      </div>
                    );
                  });
                })()}
              </div>
            </div>
          )}
        </div>
      </div>

      {loading && scanProgress < 100 && (
        <div className="flex justify-center">
          <button onClick={stopScan} className="mt-2">
            <img
              src={stopIcon}
              alt="Stop Scan"
              className="w-32 h-32 transition-transform duration-300 ease-in-out transform hover:scale-110 hover:brightness-110"
            />
          </button>
        </div>
      )}

      {/* Risk Summary */}
      {alerts.length > 0 && (
        <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-4">
          {Object.entries(getRiskCounts()).map(([risk, count]) => (
            <div
              key={risk}
              className="flex flex-col p-4 rounded-xl text-#3e67c8 text-center transition duration-300 hover:scale-105"
              style={getRiskStyles(risk)}
            >
              <div className="font-bold">{risk}</div>
              <div className="text-3xl">{count}</div>
            </div>
          ))}
        </div>
      )}

      {/* Detected Vulnerabilities */}
      {alerts.length > 0 && (
        <div
          className="mt-6 border border-gray-200 shadow-xl rounded-xl p-4"
          style={{
            background:
              "linear-gradient(to bottom, #d6f8df 0%, #ffd6e8 40%, #d6f8df 100%)",
            color: "#3e67c8",
            height: "300px",
            display: "flex",
            flexDirection: "column",
          }}
        >
          <div className="flex justify-between items-center mb-2">
            <h3 className="text-xl font-bold">Detected Vulnerabilities</h3>
            <div className="flex gap-4">
              <button
                onClick={() => generateStyledPDF(alerts)}
                className="bg-green-600 hover:bg-green-700 text-white px-3 py-1 rounded text-sm"
              >
                Download PDF
              </button>{" "}
              {/* ✅ Properly closed the button */}
              <button
                onClick={() => {
                  setShowAIReport(true);
                  generateAIReport();
                }}
                className="bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded text-sm"
              >
                AI Report
              </button>
            </div>
          </div>

          <div className="overflow-y-auto">
            <ul className="space-y-2">
              {alerts.map((alert, idx) => (
                <li key={idx} className="p-3 bg-white rounded-2xl shadow-sm">
                  <div className="font-semibold">{alert.alert}</div>
                  <div className="text-sm text-red-600">Risk: {alert.risk}</div>
                  <div className="text-sm text-gray-600">URL: {alert.url}</div>
                </li>
              ))}
            </ul>
          </div>
        </div>
      )}

      {/* Sent HTTP Messages */}
      {!loading && sentMessages.length > 0 && (
        <div
          className="mt-6 border border-gray-200 shadow-xl rounded-xl p-4"
          style={{
            background: "linear-gradient(to bottom, #fdfdfd 0%, #e0f7fa 100%)",
            color: "#3e67c8",
            height: "350px",
            display: "flex",
            flexDirection: "column",
          }}
        >
          <h3 className="text-xl font-bold mb-2">Sent HTTP Messages</h3>
          <div className="overflow-auto">
            <table className="min-w-full text-xs text-gray-700 border-collapse">
              <thead>
                <tr className="bg-gray-200">
                  <th className="p-2 border">ID</th>
                  <th className="p-2 border">Req. Timestamp</th>
                  <th className="p-2 border">Resp. Timestamp</th>
                  <th className="p-2 border">Method</th>
                  <th className="p-2 border">URL</th>
                  <th className="p-2 border">Code</th>
                  <th className="p-2 border">Reason</th>
                  <th className="p-2 border">RTT</th>
                  <th className="p-2 border">Resp. Header</th>
                  <th className="p-2 border">Resp. Body</th>
                </tr>
              </thead>
              <tbody>
                {sentMessages.map((msg, idx) => (
                  <tr key={idx} className="hover:bg-gray-100">
                    <td className="p-2 border">{msg.id}</td>
                    <td className="p-2 border">{msg.timeSent || "-"}</td>
                    <td className="p-2 border">{msg.timeReceived || "-"}</td>
                    <td className="p-2 border">{msg.method || "-"}</td>
                    <td className="p-2 border truncate max-w-xs">
                      {msg.url || "-"}
                    </td>
                    <td className="p-2 border">{msg.statusCode || "-"}</td>
                    <td className="p-2 border">{msg.reasonPhrase || "-"}</td>
                    <td className="p-2 border">{msg.rtt || "-"}</td>
                    <td className="p-2 border">
                      {msg.responseHeader?.length || 0} bytes
                    </td>
                    <td className="p-2 border">
                      {msg.responseBody?.length || 0} bytes
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        </div>
      )}

      <ToastContainer />
    </div>
  );
}

{
  /* // Helper Functions */
}

function getRiskStyles(risk) {
  switch (risk) {
    case "Critical":
      return {
        backgroundColor: "#e9a8f7",
        boxShadow: "0 4px 15px rgba(172, 168, 247, 0.57)",
      };
    case "High":
      return {
        backgroundColor: "#ff6b6b",
        boxShadow: "0 4px 15px rgba(255, 107, 107, 0.7)",
      };
    case "Medium":
      return {
        backgroundColor: "#ffb347",
        boxShadow: "0 4px 15px rgba(255, 179, 71, 0.7)",
      };
    case "Low":
      return {
        backgroundColor: "#ffe66d",
        boxShadow: "0 4px 15px rgba(255, 230, 109, 0.7)",
      };
    case "Informational":
      return {
        backgroundColor: "#cce5ff",
        boxShadow: "0 4px 15px rgba(204, 229, 255, 0.7)",
      };
    default:
      return {
        backgroundColor: "#d1d5db",
        boxShadow: "0 4px 12px rgba(0, 0, 0, 0.1)",
      };
  }
}

// Group HTTP responses by time & status class (1xx, 2xx, etc.)
function groupResponsesByTime(messages) {
  const grouped = {};
  messages.forEach(({ timeReceived, statusCode }) => {
    if (!timeReceived || !statusCode) return;
    const second = new Date(timeReceived).toISOString().slice(0, 19); // round to second
    const codeClass = `${statusCode}`.charAt(0) + "xx";
    if (!grouped[second]) grouped[second] = {};
    grouped[second][codeClass] = (grouped[second][codeClass] || 0) + 1;
  });
  return grouped;
}

function generateStyledPDF(alerts /* targetUrl*/) {
  const doc = new jsPDF();
  doc.setFontSize(18);
  /*doc.text(`Target: ${targetUrl}`, 14, 20);*/
  const riskSummary = { Critical: 0, High: 0, Medium: 0, Low: 0, Accepted: 0 };

  alerts.forEach((alert) => {
    if (riskSummary[alert.risk] !== undefined) {
      riskSummary[alert.risk]++;
    }
  });

  const total = Object.values(riskSummary).reduce((a, b) => a + b, 0);
  const getPercent = (count) => (total ? Math.round((count / total) * 100) : 0);

  // Total Vulnerabilities
  doc.setFontSize(16).text("Total Vulnerabilities", 14, 20);
  doc
    .setFontSize(10)
    .text(
      "Below are the total number of vulnerabilities found by severity.",
      14,
      26
    );

  const levels = ["Critical", "High", "Medium", "Low", "Accepted"];
  levels.forEach((level, i) => {
    doc.setFillColor(
      level === "Medium" ? "#FFD700" : level === "Low" ? "#00BFFF" : "#E0E0E0"
    );
    doc.rect(14 + i * 35, 32, 30, 20, "F");
    doc
      .setTextColor(0)
      .setFontSize(12)
      .text(`${riskSummary[level]}`, 24 + i * 35, 45, { align: "center" });
    doc.setFontSize(8).text(level, 24 + i * 35, 51, { align: "center" });
  });

  // Progress bar
  const mediumPercent = getPercent(riskSummary.Medium);
  const lowPercent = getPercent(riskSummary.Low);
  doc.setFillColor("#FFD700").rect(14, 58, (mediumPercent / 100) * 180, 8, "F");
  doc
    .setFillColor("#00BFFF")
    .rect(
      14 + (mediumPercent / 100) * 180,
      58,
      (lowPercent / 100) * 180,
      8,
      "F"
    );

  doc.setTextColor(0).setFontSize(8);
  doc.text(`${mediumPercent}%`, 14 + (mediumPercent / 2) * 1.8, 66, {
    align: "center",
  });
  doc.text(`${lowPercent}%`, 14 + (mediumPercent + lowPercent / 2) * 1.8, 66, {
    align: "center",
  });

  // Vulnerabilities Breakdown Table
  doc.addPage();
  doc.setFontSize(16).text("Vulnerabilities Breakdown", 14, 20);

  autoTable(doc, {
    startY: 28,
    head: [["Title", "Severity", "Open", "Accepted"]],
    body: alerts.map((alert) => [
      alert.alert,
      alert.risk,
      "1", // assuming each alert is open
      "0",
    ]),
    styles: { fontSize: 9 },
  });

  doc.save(`scan-report-${Date.now()}.pdf`);
}

export default VulnerabilityScan;
